\section{Row polymorphism}\label{sec:rowpolymorphism}
Row polymorphism is a typing discipline for row-based types such as records and variants \cite{Remy1993}. A row is an unordered collection of labels, e.g. 
\[ \type{student} \defas \record{\code{name}:\type{String},\code{course}:\type{String}} \]
denotes a row type with two labels: name of type \type{String} and course of type \type{String}. The record $\code{daniel} \defas \record{\code{name}="Daniel", \code{course}="cs"}$ is a possible instance of the row type \type{student}. 
%The above row is \emph{closed}, alternatively, if a row contains a row variable $\rho$, then it is said to be \emph{open}, e.g.
%\[
%\type{supervisor} \defas \record{\code{name}:\type{String} \; | \; \rho} 
%\]
%denotes a polymorphic row. Observe that the two above types both contains the label \code{name}. 

Consider a function which returns the projection of the \code{name} component and the record itself, e.g. $\code{get\_name}(r) \defas (\pi_{\code{name}}(r), r)$, where $\pi_l(r)$ is the projection of label $l$ in row $r$. This raises the question of how to type the function. One possible typing is 
\[ \code{get\_name} : \record{\code{name}:\type{a}} \to \type{a} \times \record{\code{name}:\type{a}} \]
The type looks innocuous, however, assuming that the type \type{student} is a subtype of $\record{\code{name}:\type{String}}$, then 
\[
  \code{get\_name}(\code{daniel}) = ("Daniel", \record{\code{name}="Daniel"})
\]
The output lost the \code{course} label! Because subtyping subsumed the label. However using row polymorphism, we can prevent the loss of information.
The principal idea is to extend row types with a row variable $\rho$ which can be instantiated with additional labels, thus we may type $\code{get\_name}$ as
\[ \code{get\_name} : \record{\code{name}:\type{a} \; | \; \rho} \to (a \times \record{\code{name}:\type{a} \; | \; \rho}) \]
The row \record{\code{name}:\type{a} \; | \; \rho} is said to be \emph{open} due to the presence of $\rho$, conversely, the row \type{student} is said to be \emph{closed}. If we attempt to apply \code{get\_name} to \type{daniel} under this typing then we get \code{(``Daniel'', daniel)} as desired. Under the hood the type system has to solve the equation 
\[ 
\record{\code{name}:\type{a} \; | \; \rho} \sim \record{\code{name}:\type{String},\code{course}:\type{String}}
\]
that is the two record types must be unified. The solution is to first instantiate the type variable $a$ with \type{String}, and then instantiate $\rho$ with the additional label $\code{course}$ of type $\type{String}$. The result is a row that is structural equal to the row \type{daniel}. It is crucial that either row is open, if both rows were closed then the equation would have no solutions.
%Moreover, the record type is monomorphic, that is, the type is fixed. Row polymorphism, as the name suggests, makes record types polymorphic.