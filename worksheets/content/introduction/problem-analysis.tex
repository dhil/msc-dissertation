\section{Problem analysis}
Used car-dealers got a notorious reputation for being dishonest. Dishonest, because, they are reluctant to disclose any unfortunate effects that their cars may have. On the other hand, if they \emph{did} disclose all the effects then we probably would not buy them anyway as it appears too much effort to handle those effects.

Correspondingly, some programming languages do not disclose the potential run-time effects of code execution, e.g. the ML-family of languages. For example consider the signature \code{readFile : string -> [string]} for a function in SML, its suggestive name hints that given a file name the function reads the file and return the contents line by line. In order to read a file the function must inevitably perform a side-effecting action, namely, accessing a storage media. But this information is not conveyed in the function signature.

Other languages disclose effects, albeit with varying degree. For example the Java programming language requires programmers to be explicit about potential unhandled checked exceptions that may occur during run-time, e.g. \code{String[] readFile(String f) throws IOException}. But programmers can circumvent this requirement by raising unchecked exceptions. Critics argue that Java's checked exceptions suffer versionability and scalability issues \cite{Venners03}, and therefore it is better not to have explicit \code{throws} declarations.

The Haskell programming language is also explicit about effects, but, in contrast to Java, it offers no escape hatch to be implicit. Haskell insists that every effectful computation is encapsulated inside an appropriate monad. In Haskell the file reading function would be typed as \code{readFile :: String -> IO [String]}, where the \code{IO}-annotation signifies that the function might perform an input/output side-effect. A consequence of enforcing effectful computations to be wrapped inside a monad is that the function signature conveys additional information about the computation which the programmer and compiler can rely on. 

\subsection{The problem with monads}
% Possibly reformulate this paragraph as it's copied from my IRP
Monads provide a remarkably powerful way for structuring computations, because they integrate effectful and pure computations in an elegant and flexible manner.
Sadly, monads do not compose well \cite{Kammar2013}, and accordingly it is difficult to give a monadic description of computations that might perform multiple effects.
% End of IRP phrase

\subsection{Composing monads with Monad Transformers}
% Possibly reformulate this paragraph as it's copied from my IRP
Monad transformers allow two monads to be combined by stacking one on top of the other. 
Furthermore, a monad transformer is itself a monad, and thus we can create arbitrarily complex compositions.
Incidentally, monad transformers can capture computations that may cause several different effects.
However they are no silver bullet as they impose an ordering on effects.
% End of IRP phrase